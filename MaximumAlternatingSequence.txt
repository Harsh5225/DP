Q. 1911


Top to Bottom
#define ll long long 
class Solution {
public:
ll dp[100005][2];
    ll f(vector<int>& nums,int i,bool flag)
    {
        if(i>=nums.size()) return 0;
        if(dp[i][flag]!=-1) return dp[i][flag];
        //take 
        ll take=f(nums,i+1,!flag);
        if(flag==true)
        {
            take+=nums[i];
        }
        else{
            take-=nums[i];
        }
        ll skip=f(nums,i+1,flag);
        return dp[i][flag]= max(take,skip);
    }
    long long maxAlternatingSum(vector<int>& nums) {
        memset(dp,-1,sizeof dp);
        return f(nums,0,true);
    }
};

Bottom to Top approach
#define ll long long 
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums) {
       int n=nums.size();
       vector<vector<ll>>dp(n+1,vector<ll>(2,0));  // 0 ->even // 1->odd
       for(int i=1;i<n+1;i++)
       {
        //even length ka banega   {a1,a2,a3}-> subsequence hai hai aur a4 add hoga to even length ka banega (+,-,+,-)
        dp[i][0]=max(dp[i-1][1]-nums[i-1],dp[i-1][0]);
        //odd length ka banega {a1, a2}-> a3 add hoga ->(+,-,+)->odd length
        dp[i][1]=max(dp[i-1][0]+nums[i-1],dp[i-1][1]);
       }
       return max(dp[n][1],dp[n][0]);
    }
};